import { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';
import { isAllowed, setAllowed, signTransaction, requestAccess, getAddress } from '@stellar/freighter-api';
import toast from 'react-hot-toast';
import { useStore } from '../store/useStore';

const NETWORK_PASSPHRASE = 'Test SDF Network ; September 2015';

export interface WalletContextType {
  // Connection state
  isConnected: boolean;
  address: string | null;
  walletType: 'freighter' | 'walletconnect' | null;

  // Connection methods
  connect: (type?: 'freighter' | 'walletconnect') => Promise<string | null>;
  disconnect: () => void;

  // Transaction methods
  signTransaction: (xdr: string) => Promise<string>;

  // Network info
  networkPassphrase: string;
  isCorrectNetwork: boolean;
}

const WalletContext = createContext<WalletContextType | undefined>(undefined);

interface WalletProviderProps {
  children: ReactNode;
}

export const WalletProvider = ({ children }: WalletProviderProps) => {
  const [isConnected, setIsConnected] = useState(false);
  const [address, setAddress] = useState<string | null>(null);
  const [walletType, setWalletType] = useState<'freighter' | 'walletconnect' | null>(null);
  const [isCorrectNetwork, setIsCorrectNetwork] = useState(true);

  // Get Zustand store actions
  const { setWalletAddress, setIsConnected: setStoreConnected } = useStore();

  // Sync wallet state with Zustand store whenever it changes
  useEffect(() => {
    console.log('üîÑ Syncing wallet state to store:', { address, isConnected });
    setWalletAddress(address);
    setStoreConnected(isConnected);
  }, [address, isConnected, setWalletAddress, setStoreConnected]);

  // Check for existing connection on mount
  useEffect(() => {
    const checkExistingConnection = async () => {
      const savedAddress = localStorage.getItem('wallet_address');
      const savedWalletType = localStorage.getItem('wallet_type') as 'freighter' | 'walletconnect' | null;

      if (savedAddress && savedWalletType === 'freighter') {
        try {
          const allowed = await isAllowed();
          if (allowed) {
            // Use getAddress() for previously authorized apps
            const addressObj = await getAddress();
            if (!addressObj.error && addressObj.address === savedAddress) {
              setAddress(savedAddress);
              setWalletType('freighter');
              setIsConnected(true);
            } else {
              // Clear invalid saved connection
              localStorage.removeItem('wallet_address');
              localStorage.removeItem('wallet_type');
            }
          }
        } catch (error) {
          console.error('Error checking existing connection:', error);
          localStorage.removeItem('wallet_address');
          localStorage.removeItem('wallet_type');
        }
      }
    };

    checkExistingConnection();
  }, []);

  // Connect to Freighter wallet
  const connectFreighter = useCallback(async (): Promise<string | null> => {
    try {
      console.log('üîå Attempting to connect to Freighter...');

      // Check if Freighter is installed
      const allowed = await isAllowed();
      console.log('‚úì Freighter isAllowed:', allowed);

      if (!allowed) {
        // Request access - this will show the Freighter popup
        console.log('üìù Requesting access...');
        const accessObj = await requestAccess();
        console.log('‚úì Access response:', accessObj);

        if (accessObj.error) {
          console.error('‚ùå Access error:', accessObj.error);
          toast.error('Failed to get access: ' + accessObj.error);
          return null;
        }

        const publicKey = accessObj.address;
        console.log('‚úì Got public key from requestAccess:', publicKey);

        if (!publicKey) {
          console.error('‚ùå No public key received');
          toast.error('No address received from Freighter');
          return null;
        }

        console.log('Setting state: address=', publicKey, 'walletType=freighter, isConnected=true');
        setAddress(publicKey);
        setWalletType('freighter');
        setIsConnected(true);
        setIsCorrectNetwork(true);

        // Persist connection
        localStorage.setItem('wallet_address', publicKey);
        localStorage.setItem('wallet_type', 'freighter');

        console.log('‚úÖ Wallet connected successfully!');
        toast.success(`Wallet connected: ${publicKey.slice(0,6)}...${publicKey.slice(-4)}`);
        return publicKey;
      } else {
        // Already authorized, try to get the address first
        console.log('üìç Getting existing address...');
        const addressObj = await getAddress();
        console.log('‚úì Address response:', addressObj);

        // If getAddress returns empty, use requestAccess instead
        if (!addressObj.address || addressObj.error) {
          console.log('‚ö†Ô∏è getAddress returned empty, using requestAccess instead...');
          const accessObj = await requestAccess();
          console.log('‚úì Access response:', accessObj);

          if (accessObj.error) {
            console.error('‚ùå Access error:', accessObj.error);
            toast.error('Failed to get access: ' + accessObj.error);
            return null;
          }

          const publicKey = accessObj.address;
          console.log('‚úì Got public key from requestAccess:', publicKey);

          if (!publicKey) {
            console.error('‚ùå No public key received');
            toast.error('No address received from Freighter');
            return null;
          }

          console.log('Setting state: address=', publicKey, 'walletType=freighter, isConnected=true');
          setAddress(publicKey);
          setWalletType('freighter');
          setIsConnected(true);
          setIsCorrectNetwork(true);

          // Persist connection
          localStorage.setItem('wallet_address', publicKey);
          localStorage.setItem('wallet_type', 'freighter');

          console.log('‚úÖ Wallet connected successfully!');
          toast.success(`Wallet connected: ${publicKey.slice(0,6)}...${publicKey.slice(-4)}`);
          return publicKey;
        }

        // getAddress worked, use that address
        const publicKey = addressObj.address;
        console.log('‚úì Got public key from getAddress:', publicKey);

        console.log('Setting state: address=', publicKey, 'walletType=freighter, isConnected=true');
        setAddress(publicKey);
        setWalletType('freighter');
        setIsConnected(true);
        setIsCorrectNetwork(true);

        // Persist connection
        localStorage.setItem('wallet_address', publicKey);
        localStorage.setItem('wallet_type', 'freighter');

        console.log('‚úÖ Wallet connected successfully!');
        toast.success(`Wallet connected: ${publicKey.slice(0,6)}...${publicKey.slice(-4)}`);
        return publicKey;
      }
    } catch (error) {
      console.error('‚ùå Error connecting to Freighter:', error);
      toast.error('Failed to connect to Freighter. Please ensure it is installed.');
      return null;
    }
  }, []);

  // Connect to WalletConnect (placeholder for future implementation)
  const connectWalletConnect = useCallback(async (): Promise<string | null> => {
    try {
      // This will be implemented with WalletConnect modal
      toast('WalletConnect integration coming soon!');
      return null;
    } catch (error) {
      console.error('Error connecting to WalletConnect:', error);
      toast.error('Failed to connect via WalletConnect');
      return null;
    }
  }, []);

  // Main connect method
  const connect = useCallback(async (type: 'freighter' | 'walletconnect' = 'freighter'): Promise<string | null> => {
    if (type === 'freighter') {
      return connectFreighter();
    } else {
      return connectWalletConnect();
    }
  }, [connectFreighter, connectWalletConnect]);

  // Disconnect wallet
  const disconnect = useCallback(() => {
    setAddress(null);
    setWalletType(null);
    setIsConnected(false);
    setIsCorrectNetwork(true);

    localStorage.removeItem('wallet_address');
    localStorage.removeItem('wallet_type');

    toast.success('Wallet disconnected');
  }, []);

  // Sign transaction
  const signTx = useCallback(async (xdr: string): Promise<string> => {
    if (!isConnected || !address) {
      throw new Error('Wallet not connected');
    }

    if (walletType === 'freighter') {
      try {
        const result = await signTransaction(xdr, {
          networkPassphrase: NETWORK_PASSPHRASE,
        });

        // Handle both old and new Freighter API response formats
        if (typeof result === 'string') {
          return result;
        } else if (result && typeof result === 'object' && 'signedTxXdr' in result) {
          return (result as any).signedTxXdr;
        }

        throw new Error('Invalid signature response');
      } catch (error) {
        console.error('Error signing transaction:', error);
        throw new Error('Failed to sign transaction');
      }
    }

    throw new Error('Unsupported wallet type');
  }, [isConnected, address, walletType]);

  const value: WalletContextType = {
    isConnected,
    address,
    walletType,
    connect,
    disconnect,
    signTransaction: signTx,
    networkPassphrase: NETWORK_PASSPHRASE,
    isCorrectNetwork,
  };

  return (
    <WalletContext.Provider value={value}>
      {children}
    </WalletContext.Provider>
  );
};

// Custom hook to use wallet context
export const useWallet = (): WalletContextType => {
  const context = useContext(WalletContext);

  if (!context) {
    throw new Error('useWallet must be used within a WalletProvider');
  }

  return context;
};
